// Package gen contains all the components for code generation.
package gen

const watcherTmpl = `
// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at {{.GenTime}}
package {{.PackageName}}

import (
	log "github.com/golang/glog"
    "fmt"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/model"
{{if .ContractImportPath -}}
	"{{.ContractImportPath}}"
{{- end}}
{{if .AdditionalImports -}}
{{- range .AdditionalImports}}
	"{{.}}"
{{- end}}
{{- end}}
)

func New{{.ContractTypeName}}Watchers(contractAddress common.Address) *{{.ContractTypeName}}Watchers {
	return &{{.ContractTypeName}}Watchers{
		contractAddress: contractAddress,
	}
}

type {{.ContractTypeName}}Watchers struct {
	contractAddress common.Address
}

func (w *{{.ContractTypeName}}Watchers) ContractName() string {
	return "{{.ContractTypeName}}"
}

func (w *{{.ContractTypeName}}Watchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
	return w.Start{{.ContractTypeName}}Watchers(client, eventRecvChan)
}

// Start{{.ContractTypeName}}Watchers starts up the event watchers for {{.ContractTypeName}}
func (w *{{.ContractTypeName}}Watchers) Start{{.ContractTypeName}}Watchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
    contract, err := {{.ContractTypePackage}}.New{{.ContractTypeName}}(w.contractAddress, client)
	if err != nil {
        log.Errorf("Error initializing Start{{.ContractTypeName}}: err: %v", err)
		return nil, err
	}

    var sub event.Subscription
	subs := []event.Subscription{}
{{if .EventHandlers -}}
{{- range .EventHandlers}}

    sub, err = startWatch{{.EventMethod}}(eventRecvChan, contract)
	if err != nil {
        return nil, fmt.Errorf("Error starting start{{.EventMethod}}: err: %v", err)
	}
	subs = append(subs, sub)

{{- end}}
{{- end}}

    return subs, nil
}

{{if .EventHandlers -}}
{{- range .EventHandlers}}

func startWatch{{.EventMethod}}(eventRecvChan chan model.CivilEvent, _contract *{{$.ContractTypePackage}}.{{$.ContractTypeName}}) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
    recvChan := make(chan *{{$.ContractTypePackage}}.{{.EventType}})
	sub, err := _contract.Watch{{.EventMethod}}(
		opts,
		recvChan,
	{{- if .ParamValues -}}
	{{range .ParamValues}}
        []{{.Type}}{},
	{{- end}}
	{{end}}
	)
	if err != nil {
		log.Errorf("Error starting Watch{{.EventMethod}}: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("{{.EventName}}", event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

{{- end}}
{{- end}}
`
