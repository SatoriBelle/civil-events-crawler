// Package gen contains all the components for code generation.
package gen

const filtererTmpl = `
// Code generated by 'gen/eventhandlergen.go'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'gen/filterergen_template.go' for more details
// File was generated at {{.GenTime}}
package {{.PackageName}}

import (
    log "github.com/golang/glog"
    "fmt"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"

    "github.com/joincivil/civil-events-crawler/pkg/model"
    "github.com/joincivil/civil-events-crawler/pkg/utils"
    commongen "github.com/joincivil/civil-events-crawler/pkg/generated/common"
{{if .ContractImportPath -}}
    "{{.ContractImportPath}}"
{{- end}}
{{if .AdditionalImports -}}
{{- range .AdditionalImports}}
    "{{.}}"
{{- end}}
{{- end}}
)

func New{{.ContractTypeName}}Filterers(contractAddress common.Address) *{{.ContractTypeName}}Filterers {
    contractFilterers := &{{.ContractTypeName}}Filterers{
        contractAddress: contractAddress,
        eventTypes: commongen.EventTypes{{.ContractTypeName}}(),
        eventToStartBlock: make(map[string]uint64),
        lastEvents: make([]*model.Event, 0),
    }
    for _, eventType := range contractFilterers.eventTypes {
        contractFilterers.eventToStartBlock[eventType] = {{.DefaultStartBlock}} 
    }
    return contractFilterers
}

type {{.ContractTypeName}}Filterers struct {
    contractAddress common.Address
    contract *{{.ContractTypePackage}}.{{.ContractTypeName}}
    eventTypes []string
    eventToStartBlock map[string]uint64
    lastEvents  []*model.Event
}

func (f *{{.ContractTypeName}}Filterers) ContractName() string {
    return "{{.ContractTypeName}}"
}

func (f *{{.ContractTypeName}}Filterers) ContractAddress() common.Address {
    return f.contractAddress
}

func (f *{{.ContractTypeName}}Filterers) StartFilterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
    return f.Start{{.ContractTypeName}}Filterers(client, pastEvents)
}

func (f *{{.ContractTypeName}}Filterers) EventTypes() []string {
    return f.eventTypes
}

func (f *{{.ContractTypeName}}Filterers) UpdateStartBlock(eventType string, startBlock uint64) {
    f.eventToStartBlock[eventType] = startBlock
}

func (f *{{.ContractTypeName}}Filterers) LastEvents() []*model.Event {
    return f.lastEvents
}

// Start{{.ContractTypeName}}Filterers retrieves events for {{.ContractTypeName}}
func (f *{{.ContractTypeName}}Filterers) Start{{.ContractTypeName}}Filterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
    contract, err := {{.ContractTypePackage}}.New{{.ContractTypeName}}(f.contractAddress, client)
    if err != nil {
        log.Errorf("Error initializing Start{{.ContractTypeName}}: err: %v", err)
        return err, pastEvents
    }
    f.contract = contract
    var startBlock uint64
    prevEventsLength := len(pastEvents)


{{if .EventHandlers -}}
{{- range .EventHandlers}}

    startBlock = f.eventToStartBlock["{{.EventMethod}}"]
    err, pastEvents = f.startFilter{{.EventMethod}}(startBlock, pastEvents)
    if err != nil {
        return fmt.Errorf("Error retrieving {{.EventMethod}}: err: %v", err), pastEvents
    }
    if len(pastEvents) > prevEventsLength {
        f.lastEvents = append(f.lastEvents, pastEvents[len(pastEvents) - 1])
        prevEventsLength = len(pastEvents)
    }


{{- end}}
{{- end}}

    return nil, pastEvents
}

{{if .EventHandlers -}}
{{- range .EventHandlers}}

func (f *{{$.ContractTypeName}}Filterers) startFilter{{.EventMethod}}(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
    var opts = &bind.FilterOpts{
        Start: startBlock,
    }

    log.Infof("Filtering events for {{.EventMethod}} for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
    itr, err := f.contract.Filter{{.EventMethod}}(
        opts,
    {{- if .ParamValues -}}
    {{range .ParamValues}}
        []{{.Type}}{},
    {{- end}}
    {{end}}
    )
    if err != nil {
        log.Errorf("Error getting event {{.EventMethod}}: %v", err)
        return err, pastEvents
    }
    beforeCount := len(pastEvents)
    nextEvent := itr.Next()
    for nextEvent {
        modelEvent, err := model.NewEventFromContractEvent("{{.EventMethod}}", f.ContractName(), f.contractAddress, itr.Event, utils.CurrentEpochSecsInInt64(), model.Filterer)
        if err != nil {
            log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
            continue
        }
        pastEvents = append(pastEvents, modelEvent)
        nextEvent = itr.Next()
    }
    numEventsAdded := len(pastEvents) - beforeCount
    log.Infof("{{.EventMethod}} events added: %v", numEventsAdded)
    return nil, pastEvents
}

{{- end}}
{{- end}}
`
