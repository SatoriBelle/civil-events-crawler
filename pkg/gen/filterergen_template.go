// Package gen contains all the components for code generation.
package gen

const filtererTmpl = `
// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at {{.GenTime}}
package {{.PackageName}}

import (
    log "github.com/golang/glog"
    "fmt"

    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"

    "github.com/joincivil/civil-events-crawler/pkg/model"
{{if .ContractImportPath -}}
    "{{.ContractImportPath}}"
{{- end}}
{{if .AdditionalImports -}}
{{- range .AdditionalImports}}
    "{{.}}"
{{- end}}
{{- end}}
)

func New{{.ContractTypeName}}Filterers(contractAddress common.Address) *{{.ContractTypeName}}Filterers {
	return &{{.ContractTypeName}}Filterers{
		contractAddress: contractAddress,
	}
}

type {{.ContractTypeName}}Filterers struct {
	contractAddress common.Address
	contract *{{.ContractTypePackage}}.{{.ContractTypeName}}
}

func (r *{{.ContractTypeName}}Filterers) ContractName() string {
    return "{{.ContractTypeName}}"
}

func (r *{{.ContractTypeName}}Filterers) StartFilterers(client bind.ContractBackend,
    pastEvents *[]model.CivilEvent, startBlock uint64) error {
    return r.Start{{.ContractTypeName}}Filterers(client, pastEvents, startBlock)
}

// Start{{.ContractTypeName}}Filterers retrieves events for {{.ContractTypeName}}
func (r *{{.ContractTypeName}}Filterers) Start{{.ContractTypeName}}Filterers(client bind.ContractBackend,
    pastEvents *[]model.CivilEvent, startBlock uint64) error {
    contract, err := {{.ContractTypePackage}}.New{{.ContractTypeName}}(r.contractAddress, client)
    if err != nil {
        log.Errorf("Error initializing Start{{.ContractTypeName}}: err: %v", err)
        return err
    }
	r.contract = contract

    var opts = &bind.FilterOpts{
        Start: startBlock,
    }

{{if .EventHandlers -}}
{{- range .EventHandlers}}

    err = r.startFilter{{.EventMethod}}(opts, pastEvents)
    if err != nil {
        return fmt.Errorf("Error retrieving {{.EventMethod}}: err: %v", err)
    }

{{- end}}
{{- end}}

    return nil
}

{{if .EventHandlers -}}
{{- range .EventHandlers}}

func (r *{{$.ContractTypeName}}Filterers) startFilter{{.EventMethod}}(opts *bind.FilterOpts, pastEvents *[]model.CivilEvent) error {
    itr, err := r.contract.Filter{{.EventMethod}}(
        opts,
    {{- if .ParamValues -}}
    {{range .ParamValues}}
        []{{.Type}}{},
    {{- end}}
    {{end}}
    )
    if err != nil {
        log.Errorf("Error getting event {{.EventMethod}}: %v", err)
        return err
    }
    nextEvent := itr.Next()
    for nextEvent {
        civilEvent, err := model.NewCivilEvent("{{.EventMethod}}", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
        *pastEvents = append(*pastEvents, *civilEvent)
        nextEvent = itr.Next()
    }
    return nil
}

{{- end}}
{{- end}}
`
