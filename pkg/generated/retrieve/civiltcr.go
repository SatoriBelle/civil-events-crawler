// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2018-06-07 16:00:04.082156044 +0000 UTC
package retrieve

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"math/big"
)

// RetrieveCivilTCRContractEvents retrieves events for CivilTCRContract
func RetrieveCivilTCRContractEvents(client bind.ContractBackend, contractAddress common.Address, pastEvents *[]model.CivilEvent, startBlock uint64) error {
	contract, err := contract.NewCivilTCRContract(contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return err
	}

	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	err = RetrieveChallenge(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Challenge: err: %v", err)
	}

	err = RetrieveDeposit(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Deposit: err: %v", err)
	}

	err = RetrieveApplicationWhitelisted(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationWhitelisted: err: %v", err)
	}

	err = RetrieveChallengeFailed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeFailed: err: %v", err)
	}

	err = RetrieveRewardClaimed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving RewardClaimed: err: %v", err)
	}

	err = RetrieveAppealGranted(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealGranted: err: %v", err)
	}

	err = RetrieveFailedChallengeOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving FailedChallengeOverturned: err: %v", err)
	}

	err = RetrieveSuccessfulChallengeOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving SuccessfulChallengeOverturned: err: %v", err)
	}

	err = RetrieveTouchAndRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving TouchAndRemoved: err: %v", err)
	}

	err = RetrieveGrantedAppealConfirmed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealConfirmed: err: %v", err)
	}

	err = RetrieveGovernmentTransfered(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GovernmentTransfered: err: %v", err)
	}

	err = RetrieveApplication(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Application: err: %v", err)
	}

	err = RetrieveWithdrawal(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Withdrawal: err: %v", err)
	}

	err = RetrieveApplicationRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationRemoved: err: %v", err)
	}

	err = RetrieveListingWithdrawn(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingWithdrawn: err: %v", err)
	}

	err = RetrieveAppealRequested(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealRequested: err: %v", err)
	}

	err = RetrieveGrantedAppealChallenged(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealChallenged: err: %v", err)
	}

	err = RetrieveGrantedAppealOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealOverturned: err: %v", err)
	}

	err = RetrieveListingRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingRemoved: err: %v", err)
	}

	err = RetrieveChallengeSucceeded(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeSucceeded: err: %v", err)
	}

	return nil
}

func RetrieveChallenge(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallenge(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Challenge: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Challenge", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveDeposit(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterDeposit(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Deposit: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Deposit", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveApplicationWhitelisted(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplicationWhitelisted(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationWhitelisted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ApplicationWhitelisted", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveChallengeFailed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallengeFailed(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeFailed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ChallengeFailed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveRewardClaimed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterRewardClaimed(
		opts,
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event RewardClaimed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("RewardClaimed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveAppealGranted(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterAppealGranted(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealGranted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("AppealGranted", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveFailedChallengeOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterFailedChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event FailedChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("FailedChallengeOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveSuccessfulChallengeOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterSuccessfulChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event SuccessfulChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("SuccessfulChallengeOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveTouchAndRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterTouchAndRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event TouchAndRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("TouchAndRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveGrantedAppealConfirmed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealConfirmed(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealConfirmed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealConfirmed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveGovernmentTransfered(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGovernmentTransfered(
		opts,
	)
	if err != nil {
		log.Errorf("Error getting event GovernmentTransfered: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GovernmentTransfered", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveApplication(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplication(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Application: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Application", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveWithdrawal(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterWithdrawal(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Withdrawal: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Withdrawal", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveApplicationRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplicationRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ApplicationRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveListingWithdrawn(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterListingWithdrawn(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingWithdrawn: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ListingWithdrawn", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveAppealRequested(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterAppealRequested(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealRequested: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("AppealRequested", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveGrantedAppealChallenged(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealChallenged(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealChallenged: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealChallenged", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveGrantedAppealOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveListingRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterListingRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ListingRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func RetrieveChallengeSucceeded(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallengeSucceeded(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeSucceeded: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ChallengeSucceeded", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}
