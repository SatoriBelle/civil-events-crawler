// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-03-20 17:28:45.97803 +0000 UTC
package watcher

import (
	"fmt"
	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"
)

func NewGovernmentContractWatchers(contractAddress common.Address) *GovernmentContractWatchers {
	return &GovernmentContractWatchers{
		contractAddress: contractAddress,
	}
}

type GovernmentContractWatchers struct {
	contractAddress common.Address
	contract        *contract.GovernmentContract
	activeSubs      []event.Subscription
}

func (w *GovernmentContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *GovernmentContractWatchers) ContractName() string {
	return "GovernmentContract"
}

func (w *GovernmentContractWatchers) StopWatchers() error {
	for _, sub := range w.activeSubs {
		sub.Unsubscribe()
	}
	w.activeSubs = nil
	return nil
}

func (w *GovernmentContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	return w.StartGovernmentContractWatchers(client, eventRecvChan)
}

// StartGovernmentContractWatchers starts up the event watchers for GovernmentContract
func (w *GovernmentContractWatchers) StartGovernmentContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	contract, err := contract.NewGovernmentContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartGovernmentContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchAppellateSet(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppellateSet: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGovtReparameterizationProposal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGovtReparameterizationProposal: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchNewConstProposal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startNewConstProposal: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchNewConstProposalExpired(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startNewConstProposalExpired: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchNewConstProposalFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startNewConstProposalFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchNewConstProposalPassed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startNewConstProposalPassed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchParameterSet(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startParameterSet: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchProposalExpired(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startProposalExpired: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchProposalFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startProposalFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchProposalPassed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startProposalPassed: err: %v", err)
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *GovernmentContractWatchers) startWatchAppellateSet(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractAppellateSet, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractAppellateSet)
				log.Infof("startupFn: Starting WatchAppellateSet")
				sub, err := w.contract.WatchAppellateSet(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchAppellateSet")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchAppellateSet: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchAppellateSet started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppellateSet: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppellateSet for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of AppellateSet")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting AppellateSet: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart AppellateSet")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppellateSet: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppellateSet")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppellateSet", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchAppellateSet: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchAppellateSet")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppellateSet, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchAppellateSet, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchAppellateSet, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchAppellateSet (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppellateSet, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchAppellateSet, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchAppellateSet (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchGovtReparameterizationProposal(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractGovtReparameterizationProposal, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractGovtReparameterizationProposal)
				log.Infof("startupFn: Starting WatchGovtReparameterizationProposal")
				sub, err := w.contract.WatchGovtReparameterizationProposal(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchGovtReparameterizationProposal")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchGovtReparameterizationProposal: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchGovtReparameterizationProposal started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGovtReparameterizationProposal: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGovtReparameterizationProposal for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of GovtReparameterizationProposal")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GovtReparameterizationProposal: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GovtReparameterizationProposal")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGovtReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGovtReparameterizationProposal")
				}
				modelEvent, err := model.NewEventFromContractEvent("GovtReparameterizationProposal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGovtReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGovtReparameterizationProposal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGovtReparameterizationProposal, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGovtReparameterizationProposal, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchGovtReparameterizationProposal, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchGovtReparameterizationProposal (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGovtReparameterizationProposal, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchGovtReparameterizationProposal, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchGovtReparameterizationProposal (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchNewConstProposal(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractNewConstProposal, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractNewConstProposal)
				log.Infof("startupFn: Starting WatchNewConstProposal")
				sub, err := w.contract.WatchNewConstProposal(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchNewConstProposal")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchNewConstProposal: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchNewConstProposal started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewConstProposal: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchNewConstProposal for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of NewConstProposal")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting NewConstProposal: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart NewConstProposal")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewConstProposal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewConstProposal")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewConstProposal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewConstProposal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewConstProposal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewConstProposal, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchNewConstProposal, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchNewConstProposal, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchNewConstProposal (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewConstProposal, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchNewConstProposal, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchNewConstProposal (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchNewConstProposalExpired(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractNewConstProposalExpired, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractNewConstProposalExpired)
				log.Infof("startupFn: Starting WatchNewConstProposalExpired")
				sub, err := w.contract.WatchNewConstProposalExpired(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchNewConstProposalExpired")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchNewConstProposalExpired: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchNewConstProposalExpired started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewConstProposalExpired: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchNewConstProposalExpired for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of NewConstProposalExpired")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting NewConstProposalExpired: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart NewConstProposalExpired")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewConstProposalExpired: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewConstProposalExpired")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewConstProposalExpired", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewConstProposalExpired: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewConstProposalExpired")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewConstProposalExpired, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchNewConstProposalExpired, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchNewConstProposalExpired, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchNewConstProposalExpired (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewConstProposalExpired, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchNewConstProposalExpired, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchNewConstProposalExpired (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchNewConstProposalFailed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractNewConstProposalFailed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractNewConstProposalFailed)
				log.Infof("startupFn: Starting WatchNewConstProposalFailed")
				sub, err := w.contract.WatchNewConstProposalFailed(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchNewConstProposalFailed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchNewConstProposalFailed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchNewConstProposalFailed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewConstProposalFailed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchNewConstProposalFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of NewConstProposalFailed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting NewConstProposalFailed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart NewConstProposalFailed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewConstProposalFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewConstProposalFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewConstProposalFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewConstProposalFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewConstProposalFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewConstProposalFailed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchNewConstProposalFailed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchNewConstProposalFailed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchNewConstProposalFailed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewConstProposalFailed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchNewConstProposalFailed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchNewConstProposalFailed (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchNewConstProposalPassed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractNewConstProposalPassed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractNewConstProposalPassed)
				log.Infof("startupFn: Starting WatchNewConstProposalPassed")
				sub, err := w.contract.WatchNewConstProposalPassed(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchNewConstProposalPassed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchNewConstProposalPassed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchNewConstProposalPassed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewConstProposalPassed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchNewConstProposalPassed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of NewConstProposalPassed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting NewConstProposalPassed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart NewConstProposalPassed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewConstProposalPassed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewConstProposalPassed")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewConstProposalPassed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewConstProposalPassed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewConstProposalPassed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewConstProposalPassed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchNewConstProposalPassed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchNewConstProposalPassed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchNewConstProposalPassed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewConstProposalPassed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchNewConstProposalPassed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchNewConstProposalPassed (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchParameterSet(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractParameterSet, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractParameterSet)
				log.Infof("startupFn: Starting WatchParameterSet")
				sub, err := w.contract.WatchParameterSet(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchParameterSet")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchParameterSet: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchParameterSet started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchParameterSet: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchParameterSet for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ParameterSet")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ParameterSet: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ParameterSet")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchParameterSet: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchParameterSet")
				}
				modelEvent, err := model.NewEventFromContractEvent("ParameterSet", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchParameterSet: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchParameterSet")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchParameterSet, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchParameterSet, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchParameterSet, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchParameterSet (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchParameterSet, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchParameterSet, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchParameterSet (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchProposalExpired(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractProposalExpired, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractProposalExpired)
				log.Infof("startupFn: Starting WatchProposalExpired")
				sub, err := w.contract.WatchProposalExpired(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchProposalExpired")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchProposalExpired: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchProposalExpired started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalExpired: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchProposalExpired for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ProposalExpired")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ProposalExpired: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ProposalExpired")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalExpired")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalExpired", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalExpired")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalExpired, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchProposalExpired, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchProposalExpired, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchProposalExpired (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalExpired, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchProposalExpired, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchProposalExpired (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchProposalFailed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractProposalFailed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractProposalFailed)
				log.Infof("startupFn: Starting WatchProposalFailed")
				sub, err := w.contract.WatchProposalFailed(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchProposalFailed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchProposalFailed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchProposalFailed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalFailed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchProposalFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ProposalFailed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ProposalFailed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ProposalFailed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalFailed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchProposalFailed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchProposalFailed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchProposalFailed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalFailed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchProposalFailed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchProposalFailed (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *GovernmentContractWatchers) startWatchProposalPassed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.GovernmentContractProposalPassed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.GovernmentContractProposalPassed)
				log.Infof("startupFn: Starting WatchProposalPassed")
				sub, err := w.contract.WatchProposalPassed(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchProposalPassed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchProposalPassed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchProposalPassed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalPassed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchProposalPassed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ProposalPassed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ProposalPassed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ProposalPassed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalPassed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalPassed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalPassed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalPassed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalPassed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalPassed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchProposalPassed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchProposalPassed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchProposalPassed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalPassed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchProposalPassed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchProposalPassed (b): %v", err)
				return nil
			}
		}
	}), nil
}
