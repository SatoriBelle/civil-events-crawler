// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2018-12-14 20:53:48.948557 +0000 UTC
package watcher

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilPLCRVotingContractWatchers(contractAddress common.Address) *CivilPLCRVotingContractWatchers {
	return &CivilPLCRVotingContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilPLCRVotingContractWatchers struct {
	contractAddress common.Address
	contract        *contract.CivilPLCRVotingContract
	activeSubs      []event.Subscription
}

func (w *CivilPLCRVotingContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilPLCRVotingContractWatchers) ContractName() string {
	return "CivilPLCRVotingContract"
}

func (w *CivilPLCRVotingContractWatchers) StopWatchers() error {
	for _, sub := range w.activeSubs {
		sub.Unsubscribe()
	}
	w.activeSubs = nil
	return nil
}

func (w *CivilPLCRVotingContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	return w.StartCivilPLCRVotingContractWatchers(client, eventRecvChan)
}

// StartCivilPLCRVotingContractWatchers starts up the event watchers for CivilPLCRVotingContract
func (w *CivilPLCRVotingContractWatchers) StartCivilPLCRVotingContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	contract, err := contract.NewCivilPLCRVotingContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilPLCRVotingContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchPollCreated(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startPollCreated: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchTokensRescued(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startTokensRescued: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchVoteCommitted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startVoteCommitted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchVoteRevealed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startVoteRevealed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchVotingRightsGranted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startVotingRightsGranted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchVotingRightsWithdrawn(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startVotingRightsWithdrawn: err: %v", err)
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchPollCreated(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractPollCreated, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractPollCreated)
				sub, err := w.contract.WatchPollCreated(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchPollCreated: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchPollCreated: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchPollCreated for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("PollCreated", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchPollCreated, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchPollCreated, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchTokensRescued(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractTokensRescued, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractTokensRescued)
				sub, err := w.contract.WatchTokensRescued(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchTokensRescued: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTokensRescued: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchTokensRescued for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("TokensRescued", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchTokensRescued, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchTokensRescued, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVoteCommitted(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractVoteCommitted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractVoteCommitted)
				sub, err := w.contract.WatchVoteCommitted(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchVoteCommitted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVoteCommitted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVoteCommitted for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("VoteCommitted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchVoteCommitted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchVoteCommitted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVoteRevealed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractVoteRevealed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractVoteRevealed)
				sub, err := w.contract.WatchVoteRevealed(
					opts,
					recvChan,
					[]*big.Int{},
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchVoteRevealed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVoteRevealed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVoteRevealed for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("VoteRevealed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchVoteRevealed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchVoteRevealed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVotingRightsGranted(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractVotingRightsGranted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractVotingRightsGranted)
				sub, err := w.contract.WatchVotingRightsGranted(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchVotingRightsGranted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVotingRightsGranted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVotingRightsGranted for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("VotingRightsGranted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchVotingRightsGranted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchVotingRightsGranted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVotingRightsWithdrawn(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilPLCRVotingContractVotingRightsWithdrawn, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilPLCRVotingContractVotingRightsWithdrawn)
				sub, err := w.contract.WatchVotingRightsWithdrawn(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchVotingRightsWithdrawn: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVotingRightsWithdrawn: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVotingRightsWithdrawn for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				modelEvent, err := model.NewEventFromContractEvent("VotingRightsWithdrawn", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchVotingRightsWithdrawn, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchVotingRightsWithdrawn, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}
