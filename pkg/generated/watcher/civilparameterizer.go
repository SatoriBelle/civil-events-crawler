// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-03-14 22:47:23.491562 +0000 UTC
package watcher

import (
	"fmt"
	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewParameterizerContractWatchers(contractAddress common.Address) *ParameterizerContractWatchers {
	return &ParameterizerContractWatchers{
		contractAddress: contractAddress,
	}
}

type ParameterizerContractWatchers struct {
	contractAddress common.Address
	contract        *contract.ParameterizerContract
	activeSubs      []event.Subscription
}

func (w *ParameterizerContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *ParameterizerContractWatchers) ContractName() string {
	return "ParameterizerContract"
}

func (w *ParameterizerContractWatchers) StopWatchers() error {
	for _, sub := range w.activeSubs {
		sub.Unsubscribe()
	}
	w.activeSubs = nil
	return nil
}

func (w *ParameterizerContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	return w.StartParameterizerContractWatchers(client, eventRecvChan)
}

// StartParameterizerContractWatchers starts up the event watchers for ParameterizerContract
func (w *ParameterizerContractWatchers) StartParameterizerContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	contract, err := contract.NewParameterizerContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartParameterizerContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchChallengeFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeSucceeded: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchNewChallenge(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startNewChallenge: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchProposalAccepted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startProposalAccepted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchProposalExpired(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startProposalExpired: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchReparameterizationProposal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startReparameterizationProposal: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchRewardClaimed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startRewardClaimed: err: %v", err)
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *ParameterizerContractWatchers) startWatchChallengeFailed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractChallengeFailed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractChallengeFailed)
				log.Infof("startupFn: Starting WatchChallengeFailed")
				sub, err := w.contract.WatchChallengeFailed(
					opts,
					recvChan,
					[][32]byte{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchChallengeFailed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchChallengeFailed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchChallengeFailed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ChallengeFailed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeFailed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeFailed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeFailed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeFailed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchChallengeFailed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchChallengeFailed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeFailed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchChallengeFailed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchChallengeFailed (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractChallengeSucceeded, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractChallengeSucceeded)
				log.Infof("startupFn: Starting WatchChallengeSucceeded")
				sub, err := w.contract.WatchChallengeSucceeded(
					opts,
					recvChan,
					[][32]byte{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchChallengeSucceeded")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchChallengeSucceeded: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchChallengeSucceeded started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeSucceeded for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ChallengeSucceeded")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeSucceeded: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeSucceeded")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeSucceeded")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeSucceeded")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeSucceeded, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeSucceeded, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchChallengeSucceeded, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchChallengeSucceeded (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeSucceeded, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchChallengeSucceeded, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchChallengeSucceeded (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchNewChallenge(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractNewChallenge, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractNewChallenge)
				log.Infof("startupFn: Starting WatchNewChallenge")
				sub, err := w.contract.WatchNewChallenge(
					opts,
					recvChan,
					[][32]byte{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchNewChallenge")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchNewChallenge: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchNewChallenge started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewChallenge: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchNewChallenge for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of NewChallenge")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting NewChallenge: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart NewChallenge")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewChallenge: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewChallenge")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewChallenge", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewChallenge: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewChallenge")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewChallenge, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchNewChallenge, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchNewChallenge, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchNewChallenge (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewChallenge, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchNewChallenge, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchNewChallenge (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchProposalAccepted(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractProposalAccepted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractProposalAccepted)
				log.Infof("startupFn: Starting WatchProposalAccepted")
				sub, err := w.contract.WatchProposalAccepted(
					opts,
					recvChan,
					[][32]byte{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchProposalAccepted")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchProposalAccepted: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchProposalAccepted started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalAccepted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchProposalAccepted for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ProposalAccepted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ProposalAccepted: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ProposalAccepted")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalAccepted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalAccepted")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalAccepted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalAccepted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalAccepted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalAccepted, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchProposalAccepted, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchProposalAccepted, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchProposalAccepted (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalAccepted, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchProposalAccepted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchProposalAccepted (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchProposalExpired(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractProposalExpired, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractProposalExpired)
				log.Infof("startupFn: Starting WatchProposalExpired")
				sub, err := w.contract.WatchProposalExpired(
					opts,
					recvChan,
					[][32]byte{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchProposalExpired")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchProposalExpired: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchProposalExpired started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalExpired: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchProposalExpired for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ProposalExpired")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ProposalExpired: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ProposalExpired")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalExpired")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalExpired", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalExpired")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalExpired, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchProposalExpired, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchProposalExpired, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchProposalExpired (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalExpired, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchProposalExpired, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchProposalExpired (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchReparameterizationProposal(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractReparameterizationProposal, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractReparameterizationProposal)
				log.Infof("startupFn: Starting WatchReparameterizationProposal")
				sub, err := w.contract.WatchReparameterizationProposal(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchReparameterizationProposal")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchReparameterizationProposal: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchReparameterizationProposal started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchReparameterizationProposal: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchReparameterizationProposal for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of ReparameterizationProposal")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ReparameterizationProposal: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ReparameterizationProposal")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchReparameterizationProposal")
				}
				modelEvent, err := model.NewEventFromContractEvent("ReparameterizationProposal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchReparameterizationProposal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchReparameterizationProposal, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchReparameterizationProposal, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchReparameterizationProposal, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchReparameterizationProposal (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchReparameterizationProposal, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchReparameterizationProposal, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchReparameterizationProposal (b): %v", err)
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchRewardClaimed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.ParameterizerContractRewardClaimed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.ParameterizerContractRewardClaimed)
				log.Infof("startupFn: Starting WatchRewardClaimed")
				sub, err := w.contract.WatchRewardClaimed(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchRewardClaimed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchRewardClaimed: retry: %v: %v", retry, err)
					continue
				}
				log.Infof("startupFn: WatchRewardClaimed started")
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchRewardClaimed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				log.Infof("Premptive restart of RewardClaimed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting RewardClaimed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart RewardClaimed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRewardClaimed")
				}
				modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRewardClaimed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRewardClaimed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchRewardClaimed, fatal (a): %v", err)
						return err
					}
					log.Errorf("Done error with WatchRewardClaimed, fatal (a): %v", err)
				case <-quit:
					log.Infof("Quit WatchRewardClaimed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRewardClaimed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchRewardClaimed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				log.Infof("Quit WatchRewardClaimed (b): %v", err)
				return nil
			}
		}
	}), nil
}
