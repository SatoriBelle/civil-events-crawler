// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2018-06-10 05:15:40.727822693 +0000 UTC
package watcher

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"math/big"
)

func NewCivilTCRContractWatchers(contractAddress common.Address) *CivilTCRContractWatchers {
	return &CivilTCRContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractWatchers struct {
	contractAddress common.Address
	contract        *contract.CivilTCRContract
}

func (w *CivilTCRContractWatchers) ContractName() string {
	return "CivilTCRContract"
}

func (w *CivilTCRContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
	return w.StartCivilTCRContractWatchers(client, eventRecvChan)
}

// StartCivilTCRContractWatchers starts up the event watchers for CivilTCRContract
func (w *CivilTCRContractWatchers) StartCivilTCRContractWatchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
	contract, err := contract.NewCivilTCRContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchAppealGranted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealGranted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchAppealRequested(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealRequested: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplication(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplication: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationWhitelisted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationWhitelisted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallenge(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallenge: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeSucceeded: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchDeposit(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startDeposit: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchFailedChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startFailedChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGovernmentTransfered(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGovernmentTransfered: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealChallenged(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealChallenged: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealConfirmed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealConfirmed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingWithdrawn(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingWithdrawn: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchRewardClaimed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startRewardClaimed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchSuccessfulChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startSuccessfulChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchTouchAndRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startTouchAndRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchWithdrawal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startWithdrawal: err: %v", err)
	}
	subs = append(subs, sub)

	return subs, nil
}

func (w *CivilTCRContractWatchers) startWatchAppealGranted(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractAppealGranted)
	sub, err := w.contract.WatchAppealGranted(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchAppealGranted: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_AppealGranted", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchAppealRequested(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractAppealRequested)
	sub, err := w.contract.WatchAppealRequested(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchAppealRequested: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_AppealRequested", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplication(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractApplication)
	sub, err := w.contract.WatchApplication(
		opts,
		recvChan,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchApplication: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_Application", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractApplicationRemoved)
	sub, err := w.contract.WatchApplicationRemoved(
		opts,
		recvChan,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchApplicationRemoved: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ApplicationRemoved", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationWhitelisted(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractApplicationWhitelisted)
	sub, err := w.contract.WatchApplicationWhitelisted(
		opts,
		recvChan,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchApplicationWhitelisted: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ApplicationWhitelisted", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallenge(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractChallenge)
	sub, err := w.contract.WatchChallenge(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchChallenge: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_Challenge", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeFailed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractChallengeFailed)
	sub, err := w.contract.WatchChallengeFailed(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchChallengeFailed: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ChallengeFailed", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractChallengeSucceeded)
	sub, err := w.contract.WatchChallengeSucceeded(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchChallengeSucceeded: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ChallengeSucceeded", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchDeposit(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractDeposit)
	sub, err := w.contract.WatchDeposit(
		opts,
		recvChan,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchDeposit: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_Deposit", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchFailedChallengeOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractFailedChallengeOverturned)
	sub, err := w.contract.WatchFailedChallengeOverturned(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchFailedChallengeOverturned: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_FailedChallengeOverturned", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGovernmentTransfered(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractGovernmentTransfered)
	sub, err := w.contract.WatchGovernmentTransfered(
		opts,
		recvChan,
	)
	if err != nil {
		log.Errorf("Error starting WatchGovernmentTransfered: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_GovernmentTransfered", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealChallenged(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractGrantedAppealChallenged)
	sub, err := w.contract.WatchGrantedAppealChallenged(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchGrantedAppealChallenged: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_GrantedAppealChallenged", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealConfirmed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractGrantedAppealConfirmed)
	sub, err := w.contract.WatchGrantedAppealConfirmed(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchGrantedAppealConfirmed: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_GrantedAppealConfirmed", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractGrantedAppealOverturned)
	sub, err := w.contract.WatchGrantedAppealOverturned(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchGrantedAppealOverturned: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_GrantedAppealOverturned", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractListingRemoved)
	sub, err := w.contract.WatchListingRemoved(
		opts,
		recvChan,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchListingRemoved: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ListingRemoved", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingWithdrawn(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractListingWithdrawn)
	sub, err := w.contract.WatchListingWithdrawn(
		opts,
		recvChan,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchListingWithdrawn: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_ListingWithdrawn", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchRewardClaimed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractRewardClaimed)
	sub, err := w.contract.WatchRewardClaimed(
		opts,
		recvChan,
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchRewardClaimed: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_RewardClaimed", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchSuccessfulChallengeOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractSuccessfulChallengeOverturned)
	sub, err := w.contract.WatchSuccessfulChallengeOverturned(
		opts,
		recvChan,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error starting WatchSuccessfulChallengeOverturned: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_SuccessfulChallengeOverturned", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchTouchAndRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractTouchAndRemoved)
	sub, err := w.contract.WatchTouchAndRemoved(
		opts,
		recvChan,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchTouchAndRemoved: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_TouchAndRemoved", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchWithdrawal(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	opts := &bind.WatchOpts{}
	recvChan := make(chan *contract.CivilTCRContractWithdrawal)
	sub, err := w.contract.WatchWithdrawal(
		opts,
		recvChan,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error starting WatchWithdrawal: %v", err)
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case event := <-recvChan:
				civilEvent := model.NewCivilEvent("_Withdrawal", w.contractAddress, event)
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
