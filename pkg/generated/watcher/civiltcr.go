// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2018-07-02 01:12:13.148626076 +0000 UTC
package watcher

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"math/big"
)

func NewCivilTCRContractWatchers(contractAddress common.Address) *CivilTCRContractWatchers {
	return &CivilTCRContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractWatchers struct {
	contractAddress common.Address
	contract        *contract.CivilTCRContract
	activeSubs      []event.Subscription
}

func (w *CivilTCRContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilTCRContractWatchers) ContractName() string {
	return "CivilTCRContract"
}

func (w *CivilTCRContractWatchers) StopWatchers() error {
	for _, sub := range w.activeSubs {
		sub.Unsubscribe()
	}
	w.activeSubs = nil
	return nil
}

func (w *CivilTCRContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
	return w.StartCivilTCRContractWatchers(client, eventRecvChan)
}

// StartCivilTCRContractWatchers starts up the event watchers for CivilTCRContract
func (w *CivilTCRContractWatchers) StartCivilTCRContractWatchers(client bind.ContractBackend,
	eventRecvChan chan model.CivilEvent) ([]event.Subscription, error) {
	contract, err := contract.NewCivilTCRContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchAppealGranted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealGranted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchAppealRequested(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealRequested: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplication(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplication: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationWhitelisted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationWhitelisted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallenge(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallenge: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeSucceeded: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchDeposit(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startDeposit: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchFailedChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startFailedChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGovernmentTransfered(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGovernmentTransfered: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealChallenged(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealChallenged: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealConfirmed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealConfirmed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingWithdrawn(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingWithdrawn: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchRewardClaimed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startRewardClaimed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchSuccessfulChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startSuccessfulChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchTouchAndRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startTouchAndRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchWithdrawal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startWithdrawal: err: %v", err)
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilTCRContractWatchers) startWatchAppealGranted(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractAppealGranted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractAppealGranted)
				sub, err := w.contract.WatchAppealGranted(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchAppealGranted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealGranted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealGranted for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_AppealGranted", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchAppealGranted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchAppealGranted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchAppealRequested(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractAppealRequested, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractAppealRequested)
				sub, err := w.contract.WatchAppealRequested(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchAppealRequested: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealRequested: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealRequested for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_AppealRequested", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchAppealRequested, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchAppealRequested, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplication(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplication, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplication)
				sub, err := w.contract.WatchApplication(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchApplication: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplication: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplication for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_Application", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplication, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchApplication, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplicationRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplicationRemoved)
				sub, err := w.contract.WatchApplicationRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchApplicationRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ApplicationRemoved", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplicationRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchApplicationRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationWhitelisted(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplicationWhitelisted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplicationWhitelisted)
				sub, err := w.contract.WatchApplicationWhitelisted(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchApplicationWhitelisted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationWhitelisted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationWhitelisted for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ApplicationWhitelisted", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplicationWhitelisted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchApplicationWhitelisted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallenge(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallenge, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallenge)
				sub, err := w.contract.WatchChallenge(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchChallenge: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallenge: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallenge for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_Challenge", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallenge, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchChallenge, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeFailed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallengeFailed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallengeFailed)
				sub, err := w.contract.WatchChallengeFailed(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchChallengeFailed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ChallengeFailed", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeFailed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchChallengeFailed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallengeSucceeded, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallengeSucceeded)
				sub, err := w.contract.WatchChallengeSucceeded(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchChallengeSucceeded: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeSucceeded for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ChallengeSucceeded", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeSucceeded, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchChallengeSucceeded, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchDeposit(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractDeposit, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractDeposit)
				sub, err := w.contract.WatchDeposit(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchDeposit: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchDeposit: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchDeposit for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_Deposit", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchDeposit, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchDeposit, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchFailedChallengeOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractFailedChallengeOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractFailedChallengeOverturned)
				sub, err := w.contract.WatchFailedChallengeOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchFailedChallengeOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchFailedChallengeOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchFailedChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_FailedChallengeOverturned", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchFailedChallengeOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchFailedChallengeOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGovernmentTransfered(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGovernmentTransfered, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGovernmentTransfered)
				sub, err := w.contract.WatchGovernmentTransfered(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchGovernmentTransfered: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGovernmentTransfered: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGovernmentTransfered for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_GovernmentTransfered", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGovernmentTransfered, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchGovernmentTransfered, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealChallenged(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealChallenged, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealChallenged)
				sub, err := w.contract.WatchGrantedAppealChallenged(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchGrantedAppealChallenged: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealChallenged: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealChallenged for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_GrantedAppealChallenged", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealChallenged, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchGrantedAppealChallenged, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealConfirmed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealConfirmed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealConfirmed)
				sub, err := w.contract.WatchGrantedAppealConfirmed(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchGrantedAppealConfirmed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealConfirmed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealConfirmed for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_GrantedAppealConfirmed", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealConfirmed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchGrantedAppealConfirmed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealOverturned)
				sub, err := w.contract.WatchGrantedAppealOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchGrantedAppealOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_GrantedAppealOverturned", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchGrantedAppealOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractListingRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractListingRemoved)
				sub, err := w.contract.WatchListingRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchListingRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ListingRemoved", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchListingRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchListingRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingWithdrawn(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractListingWithdrawn, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractListingWithdrawn)
				sub, err := w.contract.WatchListingWithdrawn(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchListingWithdrawn: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingWithdrawn: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingWithdrawn for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_ListingWithdrawn", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchListingWithdrawn, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchListingWithdrawn, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchRewardClaimed(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractRewardClaimed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractRewardClaimed)
				sub, err := w.contract.WatchRewardClaimed(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchRewardClaimed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchRewardClaimed for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_RewardClaimed", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchRewardClaimed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchRewardClaimed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchSuccessfulChallengeOverturned(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractSuccessfulChallengeOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractSuccessfulChallengeOverturned)
				sub, err := w.contract.WatchSuccessfulChallengeOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchSuccessfulChallengeOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchSuccessfulChallengeOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchSuccessfulChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_SuccessfulChallengeOverturned", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchSuccessfulChallengeOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchSuccessfulChallengeOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchTouchAndRemoved(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractTouchAndRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractTouchAndRemoved)
				sub, err := w.contract.WatchTouchAndRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchTouchAndRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTouchAndRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchTouchAndRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_TouchAndRemoved", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchTouchAndRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchTouchAndRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchWithdrawal(eventRecvChan chan model.CivilEvent) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractWithdrawal, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractWithdrawal)
				sub, err := w.contract.WatchWithdrawal(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("Retrying start WatchWithdrawal: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchWithdrawal: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchWithdrawal for contract %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				civilEvent, err := model.NewCivilEventFromContractEvent("_Withdrawal", w.ContractName(), w.contractAddress, event, utils.CurrentEpochSecsInInt())
				if err != nil {
					log.Errorf("Error creating new civil event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- *civilEvent:
				case err := <-sub.Err():
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchWithdrawal, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error restarting WatchWithdrawal, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}
