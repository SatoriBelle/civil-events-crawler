// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-03-05 21:05:01.146079 +0000 UTC
package watcher

import (
	"fmt"
	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/event"

	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilTCRContractWatchers(contractAddress common.Address) *CivilTCRContractWatchers {
	return &CivilTCRContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractWatchers struct {
	contractAddress common.Address
	contract        *contract.CivilTCRContract
	activeSubs      []event.Subscription
}

func (w *CivilTCRContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilTCRContractWatchers) ContractName() string {
	return "CivilTCRContract"
}

func (w *CivilTCRContractWatchers) StopWatchers() error {
	for _, sub := range w.activeSubs {
		sub.Unsubscribe()
	}
	w.activeSubs = nil
	return nil
}

func (w *CivilTCRContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	return w.StartCivilTCRContractWatchers(client, eventRecvChan)
}

// StartCivilTCRContractWatchers starts up the event watchers for CivilTCRContract
func (w *CivilTCRContractWatchers) StartCivilTCRContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event) ([]event.Subscription, error) {
	contract, err := contract.NewCivilTCRContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return nil, err
	}
	w.contract = contract

	var sub event.Subscription
	subs := []event.Subscription{}

	sub, err = w.startWatchAppealGranted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealGranted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchAppealRequested(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startAppealRequested: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplication(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplication: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationWhitelisted(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startApplicationWhitelisted: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallenge(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallenge: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeFailed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeFailed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startChallengeSucceeded: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchDeposit(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startDeposit: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchFailedChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startFailedChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGovernmentTransfered(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGovernmentTransfered: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealChallenged(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealChallenged: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealConfirmed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealConfirmed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startGrantedAppealOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingWithdrawn(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startListingWithdrawn: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchRewardClaimed(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startRewardClaimed: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchSuccessfulChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startSuccessfulChallengeOverturned: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchTouchAndRemoved(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startTouchAndRemoved: err: %v", err)
	}
	subs = append(subs, sub)

	sub, err = w.startWatchWithdrawal(eventRecvChan)
	if err != nil {
		return nil, fmt.Errorf("Error starting startWithdrawal: err: %v", err)
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilTCRContractWatchers) startWatchAppealGranted(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractAppealGranted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractAppealGranted)
				log.Infof("startupFn: Starting WatchAppealGranted")
				sub, err := w.contract.WatchAppealGranted(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchAppealGranted")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchAppealGranted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealGranted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealGranted for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of AppealGranted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting AppealGranted: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart AppealGranted")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealGranted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealGranted")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealGranted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealGranted, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchAppealGranted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealGranted, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchAppealGranted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchAppealRequested(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractAppealRequested, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractAppealRequested)
				log.Infof("startupFn: Starting WatchAppealRequested")
				sub, err := w.contract.WatchAppealRequested(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchAppealRequested")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchAppealRequested: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealRequested: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealRequested for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of AppealRequested")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting AppealRequested: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart AppealRequested")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealRequested: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealRequested")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealRequested", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealRequested, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchAppealRequested, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealRequested, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchAppealRequested, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplication(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplication, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplication)
				log.Infof("startupFn: Starting WatchApplication")
				sub, err := w.contract.WatchApplication(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchApplication")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchApplication: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplication: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplication for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of Application")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Application: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Application")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplication: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplication")
				}
				modelEvent, err := model.NewEventFromContractEvent("Application", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplication, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplication, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplication, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchApplication, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationRemoved(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplicationRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplicationRemoved)
				log.Infof("startupFn: Starting WatchApplicationRemoved")
				sub, err := w.contract.WatchApplicationRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchApplicationRemoved")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchApplicationRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ApplicationRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ApplicationRemoved: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ApplicationRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationRemoved, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplicationRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationRemoved, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchApplicationRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationWhitelisted(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractApplicationWhitelisted, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractApplicationWhitelisted)
				log.Infof("startupFn: Starting WatchApplicationWhitelisted")
				sub, err := w.contract.WatchApplicationWhitelisted(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchApplicationWhitelisted")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchApplicationWhitelisted: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationWhitelisted: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationWhitelisted for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ApplicationWhitelisted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ApplicationWhitelisted: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ApplicationWhitelisted")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationWhitelisted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationWhitelisted")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationWhitelisted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationWhitelisted, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchApplicationWhitelisted, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationWhitelisted, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchApplicationWhitelisted, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallenge(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallenge, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallenge)
				log.Infof("startupFn: Starting WatchChallenge")
				sub, err := w.contract.WatchChallenge(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchChallenge")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchChallenge: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallenge: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallenge for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of Challenge")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Challenge: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Challenge")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallenge: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallenge")
				}
				modelEvent, err := model.NewEventFromContractEvent("Challenge", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallenge, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallenge, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallenge, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchChallenge, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeFailed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallengeFailed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallengeFailed)
				log.Infof("startupFn: Starting WatchChallengeFailed")
				sub, err := w.contract.WatchChallengeFailed(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchChallengeFailed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchChallengeFailed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ChallengeFailed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeFailed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeFailed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeFailed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeFailed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeFailed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchChallengeFailed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractChallengeSucceeded, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractChallengeSucceeded)
				log.Infof("startupFn: Starting WatchChallengeSucceeded")
				sub, err := w.contract.WatchChallengeSucceeded(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchChallengeSucceeded")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchChallengeSucceeded: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeSucceeded for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ChallengeSucceeded")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeSucceeded: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeSucceeded")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeSucceeded")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeSucceeded, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchChallengeSucceeded, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeSucceeded, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchChallengeSucceeded, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchDeposit(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractDeposit, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractDeposit)
				log.Infof("startupFn: Starting WatchDeposit")
				sub, err := w.contract.WatchDeposit(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchDeposit")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchDeposit: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchDeposit: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchDeposit for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of Deposit")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Deposit: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Deposit")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchDeposit: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchDeposit")
				}
				modelEvent, err := model.NewEventFromContractEvent("Deposit", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchDeposit, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchDeposit, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchDeposit, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchDeposit, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchFailedChallengeOverturned(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractFailedChallengeOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractFailedChallengeOverturned)
				log.Infof("startupFn: Starting WatchFailedChallengeOverturned")
				sub, err := w.contract.WatchFailedChallengeOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchFailedChallengeOverturned")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchFailedChallengeOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchFailedChallengeOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchFailedChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of FailedChallengeOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting FailedChallengeOverturned: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart FailedChallengeOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchFailedChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchFailedChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("FailedChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchFailedChallengeOverturned, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchFailedChallengeOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchFailedChallengeOverturned, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchFailedChallengeOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGovernmentTransfered(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGovernmentTransfered, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGovernmentTransfered)
				log.Infof("startupFn: Starting WatchGovernmentTransfered")
				sub, err := w.contract.WatchGovernmentTransfered(
					opts,
					recvChan,
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchGovernmentTransfered")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchGovernmentTransfered: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGovernmentTransfered: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGovernmentTransfered for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of GovernmentTransfered")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GovernmentTransfered: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GovernmentTransfered")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGovernmentTransfered: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGovernmentTransfered")
				}
				modelEvent, err := model.NewEventFromContractEvent("GovernmentTransfered", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchGovernmentTransfered, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGovernmentTransfered, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGovernmentTransfered, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchGovernmentTransfered, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealChallenged(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealChallenged, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealChallenged)
				log.Infof("startupFn: Starting WatchGrantedAppealChallenged")
				sub, err := w.contract.WatchGrantedAppealChallenged(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchGrantedAppealChallenged")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchGrantedAppealChallenged: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealChallenged: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealChallenged for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of GrantedAppealChallenged")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealChallenged: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealChallenged")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealChallenged: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealChallenged")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealChallenged", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealChallenged, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealChallenged, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealChallenged, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchGrantedAppealChallenged, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealConfirmed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealConfirmed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealConfirmed)
				log.Infof("startupFn: Starting WatchGrantedAppealConfirmed")
				sub, err := w.contract.WatchGrantedAppealConfirmed(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchGrantedAppealConfirmed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchGrantedAppealConfirmed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealConfirmed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealConfirmed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of GrantedAppealConfirmed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealConfirmed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealConfirmed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealConfirmed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealConfirmed")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealConfirmed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealConfirmed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealConfirmed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealConfirmed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchGrantedAppealConfirmed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealOverturned(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractGrantedAppealOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractGrantedAppealOverturned)
				log.Infof("startupFn: Starting WatchGrantedAppealOverturned")
				sub, err := w.contract.WatchGrantedAppealOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchGrantedAppealOverturned")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchGrantedAppealOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of GrantedAppealOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealOverturned: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealOverturned, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchGrantedAppealOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealOverturned, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchGrantedAppealOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingRemoved(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractListingRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractListingRemoved)
				log.Infof("startupFn: Starting WatchListingRemoved")
				sub, err := w.contract.WatchListingRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchListingRemoved")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchListingRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ListingRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ListingRemoved: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ListingRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingRemoved, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchListingRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingRemoved, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchListingRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingWithdrawn(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractListingWithdrawn, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractListingWithdrawn)
				log.Infof("startupFn: Starting WatchListingWithdrawn")
				sub, err := w.contract.WatchListingWithdrawn(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchListingWithdrawn")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchListingWithdrawn: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingWithdrawn: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingWithdrawn for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of ListingWithdrawn")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ListingWithdrawn: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ListingWithdrawn")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingWithdrawn: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingWithdrawn")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingWithdrawn", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingWithdrawn, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchListingWithdrawn, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingWithdrawn, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchListingWithdrawn, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchRewardClaimed(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractRewardClaimed, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractRewardClaimed)
				log.Infof("startupFn: Starting WatchRewardClaimed")
				sub, err := w.contract.WatchRewardClaimed(
					opts,
					recvChan,
					[]*big.Int{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchRewardClaimed")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchRewardClaimed: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchRewardClaimed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of RewardClaimed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting RewardClaimed: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart RewardClaimed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRewardClaimed")
				}
				modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchRewardClaimed, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchRewardClaimed, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRewardClaimed, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchRewardClaimed, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchSuccessfulChallengeOverturned(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractSuccessfulChallengeOverturned, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractSuccessfulChallengeOverturned)
				log.Infof("startupFn: Starting WatchSuccessfulChallengeOverturned")
				sub, err := w.contract.WatchSuccessfulChallengeOverturned(
					opts,
					recvChan,
					[]common.Address{},
					[]*big.Int{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchSuccessfulChallengeOverturned")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchSuccessfulChallengeOverturned: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchSuccessfulChallengeOverturned: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchSuccessfulChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of SuccessfulChallengeOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting SuccessfulChallengeOverturned: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart SuccessfulChallengeOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchSuccessfulChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchSuccessfulChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("SuccessfulChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchSuccessfulChallengeOverturned, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchSuccessfulChallengeOverturned, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchSuccessfulChallengeOverturned, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchSuccessfulChallengeOverturned, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchTouchAndRemoved(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractTouchAndRemoved, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractTouchAndRemoved)
				log.Infof("startupFn: Starting WatchTouchAndRemoved")
				sub, err := w.contract.WatchTouchAndRemoved(
					opts,
					recvChan,
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchTouchAndRemoved")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchTouchAndRemoved: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTouchAndRemoved: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchTouchAndRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of TouchAndRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting TouchAndRemoved: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart TouchAndRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchTouchAndRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchTouchAndRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("TouchAndRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchTouchAndRemoved, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchTouchAndRemoved, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchTouchAndRemoved, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchTouchAndRemoved, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchWithdrawal(eventRecvChan chan *model.Event) (event.Subscription, error) {
	return event.NewSubscription(func(quit <-chan struct{}) error {
		maxRetries := 5
		startupFn := func() (event.Subscription, chan *contract.CivilTCRContractWithdrawal, error) {
			retry := 0
			for {
				opts := &bind.WatchOpts{}
				recvChan := make(chan *contract.CivilTCRContractWithdrawal)
				log.Infof("startupFn: Starting WatchWithdrawal")
				sub, err := w.contract.WatchWithdrawal(
					opts,
					recvChan,
					[]common.Address{},
					[]common.Address{},
				)
				if err != nil {
					if sub != nil {
						log.Infof("startupFn: Unsubscribing WatchWithdrawal")
						sub.Unsubscribe()
					}
					if retry >= maxRetries {
						return nil, nil, err
					}
					retry++
					log.Warningf("startupFn: Retrying start WatchWithdrawal: %v", err)
					continue
				}
				return sub, recvChan, nil
			}
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchWithdrawal: %v", err)
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchWithdrawal for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 15 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(60*15)):
				// log.Infof("Premptive restart of Withdrawal")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Withdrawal: %v", err)
					return err
				}
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Withdrawal")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchWithdrawal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchWithdrawal")
				}
				modelEvent, err := model.NewEventFromContractEvent("Withdrawal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
				case err := <-sub.Err():
					log.Errorf("Error with WatchWithdrawal, fatal (a): %v", err)
					sub.Unsubscribe()
					sub, recvChan, err = startupFn()
					if err != nil {
						log.Errorf("Error restarting WatchWithdrawal, fatal (a): %v", err)
						return err
					}
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchWithdrawal, fatal (b): %v", err)
				sub.Unsubscribe()
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("WATCHER: Error restarting WatchWithdrawal, fatal (b): %v", err)
					return err
				}
			case <-quit:
				return nil
			}
		}
	}), nil
}
