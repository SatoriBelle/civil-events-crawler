// Code generated by 'gen/eventhandlergen.go'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'gen/filterergen_template.go' for more details
// File was generated at 2018-06-14 21:01:04.867320743 +0000 UTC
package filterer

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"math/big"
)

var eventNamesCivilTCRContract = []string{
	"AppealGranted",
	"AppealRequested",
	"Application",
	"ApplicationRemoved",
	"ApplicationWhitelisted",
	"Challenge",
	"ChallengeFailed",
	"ChallengeSucceeded",
	"Deposit",
	"FailedChallengeOverturned",
	"GovernmentTransfered",
	"GrantedAppealChallenged",
	"GrantedAppealConfirmed",
	"GrantedAppealOverturned",
	"ListingRemoved",
	"ListingWithdrawn",
	"RewardClaimed",
	"SuccessfulChallengeOverturned",
	"TouchAndRemoved",
	"Withdrawal",
}

func NewCivilTCRContractFilterers(contractAddress common.Address) *CivilTCRContractFilterers {
	var c CivilTCRContractFilterers
	c.contractAddress = contractAddress
	c.eventNames = eventNamesCivilTCRContract
	c.eventToStartBlock = make(map[string]uint64)
	for _, eventName := range c.eventNames {
		c.eventToStartBlock[eventName] = 0
	}
	return &c
}

type CivilTCRContractFilterers struct {
	contractAddress   common.Address
	contract          *contract.CivilTCRContract
	eventNames        []string
	eventToStartBlock map[string]uint64
}

func (f *CivilTCRContractFilterers) ContractName() string {
	return "CivilTCRContract"
}

func (f *CivilTCRContractFilterers) StartFilterers(client bind.ContractBackend, pastEvents *[]model.CivilEvent) error {
	return f.StartCivilTCRContractFilterers(client, pastEvents)
}

func (f *CivilTCRContractFilterers) EventNames() []string {
	return f.eventNames
}

func (f *CivilTCRContractFilterers) UpdateStartBlock(eventName string, startBlock int) {
	f.eventToStartBlock[eventName] = uint64(startBlock)
}

// StartCivilTCRContractFilterers retrieves events for CivilTCRContract
func (f *CivilTCRContractFilterers) StartCivilTCRContractFilterers(client bind.ContractBackend, pastEvents *[]model.CivilEvent) error {
	contract, err := contract.NewCivilTCRContract(f.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return err
	}
	f.contract = contract
	var startBlock uint64

	startBlock = f.eventToStartBlock["AppealGranted"]
	err = f.startFilterAppealGranted(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealGranted: err: %v", err)
	}
	startBlock = f.eventToStartBlock["AppealRequested"]
	err = f.startFilterAppealRequested(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealRequested: err: %v", err)
	}
	startBlock = f.eventToStartBlock["Application"]
	err = f.startFilterApplication(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Application: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ApplicationRemoved"]
	err = f.startFilterApplicationRemoved(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationRemoved: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ApplicationWhitelisted"]
	err = f.startFilterApplicationWhitelisted(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationWhitelisted: err: %v", err)
	}
	startBlock = f.eventToStartBlock["Challenge"]
	err = f.startFilterChallenge(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Challenge: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ChallengeFailed"]
	err = f.startFilterChallengeFailed(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeFailed: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ChallengeSucceeded"]
	err = f.startFilterChallengeSucceeded(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeSucceeded: err: %v", err)
	}
	startBlock = f.eventToStartBlock["Deposit"]
	err = f.startFilterDeposit(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Deposit: err: %v", err)
	}
	startBlock = f.eventToStartBlock["FailedChallengeOverturned"]
	err = f.startFilterFailedChallengeOverturned(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving FailedChallengeOverturned: err: %v", err)
	}
	startBlock = f.eventToStartBlock["GovernmentTransfered"]
	err = f.startFilterGovernmentTransfered(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GovernmentTransfered: err: %v", err)
	}
	startBlock = f.eventToStartBlock["GrantedAppealChallenged"]
	err = f.startFilterGrantedAppealChallenged(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealChallenged: err: %v", err)
	}
	startBlock = f.eventToStartBlock["GrantedAppealConfirmed"]
	err = f.startFilterGrantedAppealConfirmed(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealConfirmed: err: %v", err)
	}
	startBlock = f.eventToStartBlock["GrantedAppealOverturned"]
	err = f.startFilterGrantedAppealOverturned(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealOverturned: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ListingRemoved"]
	err = f.startFilterListingRemoved(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingRemoved: err: %v", err)
	}
	startBlock = f.eventToStartBlock["ListingWithdrawn"]
	err = f.startFilterListingWithdrawn(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingWithdrawn: err: %v", err)
	}
	startBlock = f.eventToStartBlock["RewardClaimed"]
	err = f.startFilterRewardClaimed(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving RewardClaimed: err: %v", err)
	}
	startBlock = f.eventToStartBlock["SuccessfulChallengeOverturned"]
	err = f.startFilterSuccessfulChallengeOverturned(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving SuccessfulChallengeOverturned: err: %v", err)
	}
	startBlock = f.eventToStartBlock["TouchAndRemoved"]
	err = f.startFilterTouchAndRemoved(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving TouchAndRemoved: err: %v", err)
	}
	startBlock = f.eventToStartBlock["Withdrawal"]
	err = f.startFilterWithdrawal(startBlock, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Withdrawal: err: %v", err)
	}

	return nil
}

func (f *CivilTCRContractFilterers) startFilterAppealGranted(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterAppealGranted(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealGranted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("AppealGranted", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterAppealRequested(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterAppealRequested(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealRequested: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("AppealRequested", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterApplication(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterApplication(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Application: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("Application", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterApplicationRemoved(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterApplicationRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ApplicationRemoved", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterApplicationWhitelisted(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterApplicationWhitelisted(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationWhitelisted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ApplicationWhitelisted", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterChallenge(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterChallenge(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Challenge: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("Challenge", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterChallengeFailed(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterChallengeFailed(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeFailed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ChallengeFailed", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterChallengeSucceeded(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterChallengeSucceeded(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeSucceeded: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ChallengeSucceeded", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterDeposit(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterDeposit(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Deposit: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("Deposit", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterFailedChallengeOverturned(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterFailedChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event FailedChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("FailedChallengeOverturned", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterGovernmentTransfered(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterGovernmentTransfered(
		opts,
	)
	if err != nil {
		log.Errorf("Error getting event GovernmentTransfered: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("GovernmentTransfered", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealChallenged(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterGrantedAppealChallenged(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealChallenged: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("GrantedAppealChallenged", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealConfirmed(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterGrantedAppealConfirmed(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealConfirmed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("GrantedAppealConfirmed", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealOverturned(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterGrantedAppealOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("GrantedAppealOverturned", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterListingRemoved(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterListingRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ListingRemoved", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterListingWithdrawn(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterListingWithdrawn(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingWithdrawn: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("ListingWithdrawn", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterRewardClaimed(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterRewardClaimed(
		opts,
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event RewardClaimed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("RewardClaimed", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterSuccessfulChallengeOverturned(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterSuccessfulChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event SuccessfulChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("SuccessfulChallengeOverturned", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterTouchAndRemoved(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterTouchAndRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event TouchAndRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("TouchAndRemoved", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func (f *CivilTCRContractFilterers) startFilterWithdrawal(startBlock uint64, pastEvents *[]model.CivilEvent) error {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}
	itr, err := f.contract.FilterWithdrawal(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Withdrawal: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent, err := model.NewCivilEvent("Withdrawal", r.contractAddress, itr.Event)
		if err != nil {
			log.Errorf("Error creating new civil event: event: %v, err: %v", itr.Event, err)
			continue
		}
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}
