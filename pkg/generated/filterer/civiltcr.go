// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2018-06-10 03:46:15.954451235 +0000 UTC
package filterer

import (
	"fmt"
	log "github.com/golang/glog"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	"github.com/joincivil/civil-events-crawler/pkg/generated/contract"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"math/big"
)

func NewCivilTCRContractFilterers(contractAddress common.Address) *CivilTCRContractFilterers {
	return &CivilTCRContractFilterers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractFilterers struct {
	contractAddress common.Address
}

func (r *CivilTCRContractFilterers) ContractName() string {
	return "CivilTCRContract"
}

func (r *CivilTCRContractFilterers) StartFilterers(client bind.ContractBackend, contractAddress common.Address,
	pastEvents *[]model.CivilEvent, startBlock uint64) error {
	return r.StartCivilTCRContractFilterers(client, pastEvents, startBlock)
}

// StartCivilTCRContractFilterers retrieves events for CivilTCRContract
func (r *CivilTCRContractFilterers) StartCivilTCRContractFilterers(client bind.ContractBackend,
	pastEvents *[]model.CivilEvent, startBlock uint64) error {
	contract, err := contract.NewCivilTCRContract(r.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return err
	}

	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	err = startFilterAppealGranted(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealGranted: err: %v", err)
	}

	err = startFilterAppealRequested(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving AppealRequested: err: %v", err)
	}

	err = startFilterApplication(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Application: err: %v", err)
	}

	err = startFilterApplicationRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationRemoved: err: %v", err)
	}

	err = startFilterApplicationWhitelisted(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ApplicationWhitelisted: err: %v", err)
	}

	err = startFilterChallenge(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Challenge: err: %v", err)
	}

	err = startFilterChallengeFailed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeFailed: err: %v", err)
	}

	err = startFilterChallengeSucceeded(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ChallengeSucceeded: err: %v", err)
	}

	err = startFilterDeposit(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Deposit: err: %v", err)
	}

	err = startFilterFailedChallengeOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving FailedChallengeOverturned: err: %v", err)
	}

	err = startFilterGovernmentTransfered(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GovernmentTransfered: err: %v", err)
	}

	err = startFilterGrantedAppealChallenged(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealChallenged: err: %v", err)
	}

	err = startFilterGrantedAppealConfirmed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealConfirmed: err: %v", err)
	}

	err = startFilterGrantedAppealOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving GrantedAppealOverturned: err: %v", err)
	}

	err = startFilterListingRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingRemoved: err: %v", err)
	}

	err = startFilterListingWithdrawn(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving ListingWithdrawn: err: %v", err)
	}

	err = startFilterRewardClaimed(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving RewardClaimed: err: %v", err)
	}

	err = startFilterSuccessfulChallengeOverturned(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving SuccessfulChallengeOverturned: err: %v", err)
	}

	err = startFilterTouchAndRemoved(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving TouchAndRemoved: err: %v", err)
	}

	err = startFilterWithdrawal(opts, contract, pastEvents)
	if err != nil {
		return fmt.Errorf("Error retrieving Withdrawal: err: %v", err)
	}

	return nil
}

func startFilterAppealGranted(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterAppealGranted(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealGranted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("AppealGranted", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterAppealRequested(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterAppealRequested(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event AppealRequested: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("AppealRequested", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterApplication(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplication(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Application: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Application", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterApplicationRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplicationRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ApplicationRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterApplicationWhitelisted(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterApplicationWhitelisted(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ApplicationWhitelisted: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ApplicationWhitelisted", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterChallenge(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallenge(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Challenge: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Challenge", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterChallengeFailed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallengeFailed(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeFailed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ChallengeFailed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterChallengeSucceeded(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterChallengeSucceeded(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event ChallengeSucceeded: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ChallengeSucceeded", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterDeposit(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterDeposit(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Deposit: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Deposit", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterFailedChallengeOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterFailedChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event FailedChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("FailedChallengeOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterGovernmentTransfered(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGovernmentTransfered(
		opts,
	)
	if err != nil {
		log.Errorf("Error getting event GovernmentTransfered: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GovernmentTransfered", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterGrantedAppealChallenged(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealChallenged(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealChallenged: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealChallenged", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterGrantedAppealConfirmed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealConfirmed(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealConfirmed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealConfirmed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterGrantedAppealOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterGrantedAppealOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event GrantedAppealOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("GrantedAppealOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterListingRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterListingRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ListingRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterListingWithdrawn(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterListingWithdrawn(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event ListingWithdrawn: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("ListingWithdrawn", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterRewardClaimed(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterRewardClaimed(
		opts,
		[]*big.Int{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event RewardClaimed: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("RewardClaimed", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterSuccessfulChallengeOverturned(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterSuccessfulChallengeOverturned(
		opts,
		[]common.Address{},
		[]*big.Int{},
	)
	if err != nil {
		log.Errorf("Error getting event SuccessfulChallengeOverturned: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("SuccessfulChallengeOverturned", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterTouchAndRemoved(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterTouchAndRemoved(
		opts,
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event TouchAndRemoved: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("TouchAndRemoved", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}

func startFilterWithdrawal(opts *bind.FilterOpts, _contract *contract.CivilTCRContract, pastEvents *[]model.CivilEvent) error {
	itr, err := _contract.FilterWithdrawal(
		opts,
		[]common.Address{},
		[]common.Address{},
	)
	if err != nil {
		log.Errorf("Error getting event Withdrawal: %v", err)
		return err
	}
	nextEvent := itr.Next()
	for nextEvent {
		civilEvent := model.NewCivilEvent("Withdrawal", itr.Event)
		*pastEvents = append(*pastEvents, *civilEvent)
		nextEvent = itr.Next()
	}
	return nil
}
